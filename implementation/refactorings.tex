\chapter{Refactoring spreadsheets}
\label{chapter:implementingrefactorings}

\noindent
\begin{figure}[h!]
\hspace*{0.003\textwidth}
\input{implementation/refactoring-process-impl}
\caption{This chapter details the AST to AST transformations that implement the refactorings.}
\end{figure}

Refactoring a spreadsheet involves changing the worksheets, cells and formulas in a workbook in such a way that the desired change is performed.
Excel provides an API to change the worksheet and cells, and most other elements of a workbook.
When it is desired to refactor formulas this means the original formula string must be changed into a new formula string.
This is usually implemented by parsing the formula, performing the desired transformations on the AST and then printing the AST back to a string form \cite{fowler1999refactoring}.
The inner workings of the parser are described in Chapter \ref{chapter:parsing}.
This Chapter covers how the AST is transformed for each refactoring.

The refactorings were implemented in the BumbleBee Excel Add-In, and presented to the user through a context menu as seen in Figure X.
This context-menu automatically determines if a refactoring can be performed on the specific selected cell(s) and disables inapplicable refactorings.
\todo{Screenshot van het bumblebee refactoring context-menu}

It must be noted that all refactorings have a major deficiency: they cannot be undone. \fw
The reason for this is a technical limitation imposed by Excel: the Excel undo-redo stack is not available to Excel Add-Ins.
Instead as soon as a Excel Add-In changes the Excel spreadsheet file, in fact as soon as it interacts with the internal document model even if it does not change anything, the Excel undo-redo stack gets cleared.
While there are several non-trivial workarounds for this involving a manually creating an undo stack, the author deemed them outside of the scope of this thesis.
In an industrial-strength application this functionality would be essential.
As long as Excel keeps this limitation this will always be a severe limitation to any tool that automatically changes spreadsheet files for the user, thus Microsoft could modify Excel to facilitate these and similar Add-Ins. \fw

\section{Refactorings provided by excel}

Several useful refactorings one could think of are already provided by Excel, although Excel does not call them refactorings.

\section{\rf{Extract formula}}

The goal of the \rf{extract formula} refactoring is to move part of a formula expression, a sub-formula, to another cell, which has the following potential use cases:

\begin{enumerate}
\itemsep0em
\item Remove "magic numbers" or other constants and make them easy to adjust.
\item Make a formula easier to understand by splitting it into more smaller components.
\item Reduce duplication in a formula by extracting common sub-formulas into another cell.
\end{enumerate}

\subsection{User interface}

\begin{figure}
%\begin{minipage}[c][8cm][c]{0.5\textwidth}
%\centering
%\vspace*{\fill}
%\includegraphics[height=3cm]{implementation/extractformula/21}
%\subcaption{User selects cells to be refactored}
%\label{fig:extractformulaexample2a}
%
%\includegraphics[height=3cm]{implementation/extractformula/23}
%\addtocounter{subfigure}{1}
%\subcaption{Refactoring has been performed}
%\label{fig:extractformulaexample2c}
%\end{minipage}
%\begin{minipage}[c][8cm][t]{0.5\textwidth}
%\vspace*{\fill}
%\centering
%\includegraphics[height=7cm]{implementation/extractformula/22}
%\addtocounter{subfigure}{-2}
%\subcaption{User selects subformula to be extracted}
%\label{fig:extractformulaexample2b}
%\end{minipage}
\centering
\includegraphics{{implementation/extractformula/UI\string_Extractformula\string_arrows\string_pdf}}
\caption{An example application of \rf{Extract Formula}.}
\label{fig:extractformulaexample2}
\end{figure}

The refactoring requires the user to select cell(s) to be refactored, type in the subformula to be extracted and select where the extraction should occur to.
Figure \ref{fig:extractformulaexample2} shows the process as experienced by the user.
The user first selects the formulas to be extracted (Figure \ref{fig:extractformulaexample2}a) and clicks the Extract Formula entry in the refactoring context menu (not shown).
A side-panel pops out which allows the user to enter the sub-formula to be extracted and where it should be extracted to (Figure \ref{fig:extractformulaexample2}b) and presses the Extract Formula button.
In the example the \f{50\%} subformula was extracted to the left, and Figure \ref{fig:extractformulaexample2}c shows the situation after the user has named the new column.

The UI could be improved in two ways: the user could select the subformula to extract or the options for extraction could be provided.
The usability of both options is unclear, for example in large formulas the user might be overwhelmed by the options presented and both were not implemented.
The author leaves this a future work.

\subsection{Implementation}

This section describes the details of the refactoring implementation, which consists of 2 parts: an AST tranformation fo the formula, and a 
The first part operates solely on the formula and refactors it to the desired form, the second part handles actual placement of the formula in the cells and the moving if necessary.

\subsubsection{AST Transformation}
\label{subsec:astreplacementtransformation}

The AST transformation takes the original AST, the AST to replace and the replacement AST.
Then the original AST is traversed and every occurrence of the AST to replace is replaced by the replacement AST, yielding the new AST, this is illustrated in Figure \ref{fig:extractformulaASTtransformations}.
The C\# code for the AST replacement can be found in Listing \ref{lst:astreplace}.

This transformation is somewhat similar to the BumbleBee 1 formula transformation rules.
However, it is complimentary rather than identical as can be seen by comparing Figure \ref{fig:extractformulaASTtransformations} and Figure \ref{fig:bbv1transformationrule}.
We could have tried to written this transformation as a rule "\f{=I2 + [a] * I2}".
However, BumbleBee 1 would have searched for the "outer" formula, keeping the \f{[a]} $\gets$ \f{50\%} available for the replacement rule.
In contrast, this transformation searches for the \f{[a]} "inner" formula, and replaces it with something different.

\subsubsection{Spreadsheet refactoring}

The AST replacement is performed on the original formula, and the new formula is assigned to the cell that needs to be refactored.
If multiple cells are refactored at once, the AST replacement is performed on all of them.
Formulas with the same original R1C1 formula will have the same new R1C1 formula, so the AST replacement is only performed once per unique R1C1 formula.

If the target of the extraction is a single cell, that cell gets assigned the subformula that will be extracted, otherwise if the user wants to extract in a direction, new cells are created in the appropriate direction and all will get assigned the subformula that will be extracted.

The C\# code for the spreadsheet refactoring can be found in Listing \ref{lst:extractformula}.

\begin{figure}
	\centering
	\input{implementation/extractformula/extractformulaast.tex}
	\caption{AST transformation to implement extract formula refactoring}
	\label{fig:extractformulaASTtransformations}
\end{figure}

\begin{figure}
	\centering
	\input{implementation/extractformula/bumblebeeTransformation.tex}
	\caption{Bumblebee v1 transformation rule}
	\label{fig:bbv1transformationrule}
\end{figure}

\newpage

\subsection{Detection of applicability}

Extract formula is always applicable to a formula cell, as even a very simple formula like \f{=A1} still has a component that can be extracted.
In this case if \f{=A1} would be extracted to \f{B1} the original cell would become \f{=B1}.
This could be repeated endlessly, similarly to how one could always extract a method that only consists of a call to another method.
Whether it is a good thing to perform this refactoring is dubious, but BumbleBee relies on the user to make this assessment.

\subsection{Improvements over RefBook \rf{Extract row or column} and \rf{Extract Literal}}
\label{subsubsec:improvementsextractformula}

Two specialized versions of this refactorings where previously described by Bamade and Dig \cite{badame2012refactoring} and implemented in their RefBook tool.
Refbooks \rf{Extract Row or column} and \rf{Extract Literal} refactorings can both be performed by \rf{Extract formula}.

The author has chosen to not keep the \rf{extract row or column} refactoring name because it does not fully describe the refactoring, a full row or column does not necessarily have to be extracted, and to keep the name in line with refactoring names in other domains.

The RefBook \rf{extract literal} refactoring can put a constant value into a cell and replace the occurrences of it with references to that cell, this can also be achieved with the BumbleBee \rf{extract formula} refactoring.
In addition this is possible for any constant expression, an expression without references, instead of only for constants.

The BumbleBee \rf{Extract Formula} refactoring has several advantages over Badame's implementation of \rf{Extract row or column}.
Firstly RefBook does not handle operator precedence.
This can be very problematic for this refactoring and in the authors opinion should prevent is from being implemented, because one of the prime properties of a refactoring should be that it does not change the program results.
Note that the RefBook authors were aware of this deficiency, and left this as future work.
This future work has been performed by the thesis author.

Secondly RefBook can only handle a single row or column, which has to have exactly the same R1C1 formula. It can only extract the subformula to a column right of or row up of the original range.
BumbleBee can handle arbitrarily shaped ranges, with the only requirement that the subformula to be extracted occurs in all selected formulas.
Furthermore in addition to extracting to a cell neighboring the original formula cell (up, down, left or right) it can also extract the subformula to a single shared cell location.
This is very useful to remove duplication and makes the refactoring more universal by merging the \rf{extract literal} refactoring into it.

\section{\rf{Inline Formula}}

The goal of the \rf{Inline Formula} refactoring is to replace all references to a cell with its contents and delete the original cell, and is therefore the inverse of the \rf{Extract Formula} refactoring.
The main potential use case for this formula is when the contents of a cell are clearer or just as clear as a cell reference.

While single cell references (e.g. \f{=SUM(A1,A2,A3)}) can always be inlined, if a cell is referenced as part of a range (e.g. \f{=SUM(A1:A3)}) it can not always be inlined.
If in the previous example \f{A1} would contain \f{20}, the first formula would turn out fine: \f{=SUM(20,A2,A3)}, while the formula \f{=SUM(20:A3)} is invalid.
It might be possible to handle inlining into ranges using array formulas, but the extra complexity this would introduce in the formulas never outweighs the benefit of inlining in the authors opinion.
Some formulas might be able to be rewritten, e.g. \f{=SUM(A1:A3)} could become \f{=SUM(20,A2:A3)}, but this does not work in every case (e.g. \f{A1} cannot be inlined into \f{=A1:A5 3:3}) and thus such behavior has a higher chance to introduce errors and confuse users.
For these reasons the implementation does not perform the refactoring if the cell is referenced as part of a range.

For similar reasons, this refactoring cannot be performed on cells which are part of a named range consisting of more than one cell.

\subsection{User interface}

The refactoring is a one-click refactoring that is activated from the cell context menu, no additional user input in normally needed.

If one of the selected cells is referenced as part of a range, the user gets the choice to either abort the refactoring or continue replacing all references where the cell isn't part of a range.

\begin{figure}
	\centering
	\input{implementation/extractformula/inlineformula.tex}
	\caption{\rf{Inline Formula} reverse AST transformation of the \rf{Extract Formula} AST transformation of Figure \ref{fig:extractformulaASTtransformations}.}
	\label{fig:inlineformulaAST}
\end{figure}

\subsection{Implementation}

If a formula cell $D$ contains a reference to cell $P$, $D$ is called a dependent of $P$, and $P$ is called a precedent of $D$.
This refactoring works by first collecting all dependents of the to be inlined cell.
This information is provided by Excel, although it could be manually constructed by parsing all formulas and building a dependency graph.

In every dependent a reference to the to be inlined cell is replaced by its contents, using the same AST transformation used by \rf{Extract Formula} as described in Section \ref{subsec:astreplacementtransformation}, with a reference to the cell as the AST to replace and the cell contents as the replacement AST.
This is also illustrated in Figure \ref{fig:inlineformulaAST}, which shows the \rf{Inline Formula} inverse action of the transformation performed in Figure \ref{fig:extractformulaASTtransformations}.
If the refactoring is successful, the original cell is deleted.

The refactoring can be performed on multiple cells at the same time.
To achieve this the above process is simply repeated.

The C\# code for this spreadsheet refactoring can be found in Listing \ref{lst:inlineformula}.

\subsection{Detection of applicability}

As described in the introduction of this section, \rf{Inline Formula} is applicable to all cells which have dependents but are not referenced as part of ranges.
For speed purposed however, the BumbleBee refactoring context menu only check whether the cell has any dependents.
Doing the full check would introduce significant delay every time the user would right click.

\section{\rf{Group References}}

In the spreadsheet formula language, some built-in functions have the ability to accept a variable number of arguments, most prominently \f{SUM}, the most commonly used function \cite{hermans2014enron}.
These functions also accept ranges, and thus the formulas \f{=SUM(A1,A2,A3,A4)} and \f{=SUM(A1:A4)} are equivalent.
The \rf{Group References} was defined but not implemented by Hermans et. al \cite{hermans2014detecting} and assumes spreadsheet users prefer range usage like \f{=SUM(A1:A4)} over individual cell references like \f{SUM(A1,A2,A3,A4)}, and merges multiple adjacent cell references into a single range reference.

\subsection{User Interface}

\todo{Hmm, deze stuktjes worden erg repetaties/oninformatief. Misschien bij introductie zeggen dat dit de standaard manier is en alleen waar nodig een subsectie over maken.}

The refactoring is a one-click refactoring that is activated from the cell context menu, no additional user input is needed.

\subsection{Grouping algorithm}

In order to find the best grouping we have to solve the following problem: given a sheet with a certain set of cells selected, what are the ranges that select exactly those cells and do so with a minimum amount of ranges?

It turns out that this is a NP-hard problem, because it has a straightforward translation to a NP-hard version of the Polygon Covering problem, specifically covering a rectilinear polygon (the selected cells) with axis-parallel rectangles (ranges), allowing for holes.
This allows us to use an approximation algorithm or heuristic.
A $O(\sqrt{\log{n}})$ approximation algorithm for this specific problem has been found by Kumar and Ramesh \cite{kumar2003covering}, but implementing this would take a non-trivial amount of effort.
This makes using a simple heuristic attractive since it will probably be good enough for this purpose since the majority of refactorings will consist of simple cases.

However, rather than implementing a heuristic ourselves, this is currently delegated to Excel which contains this functionality.
The algorithm Excel uses for this is unknown.

\subsection{Implementation}

The implementation traverses the formula AST, and for every function with a variable number of arguments it encounters groups it references by excluding all non-references (e.g. constants) and sending these to Excel to be grouped.
The function arguments then are replaced by grouped references and the AST is printed back to the formula cell.
References are processed separately depending on their absolute markers, e.g. \f{A1},\f{\$A1}, \f{A\$1} and \f{\$A\$1}, because grouping references with different markers cannot be done without changing the meaning of the formula.

If multiple cells are selected, the refactoring is repeated for every one.

The C\# code for this refactoring can be found in Listing \ref{lst:groupreferences}

\subsection{Detection of applicability}

This refactoring will be available to the user if the formula contains 2 or more references.

\section{\rf{Replace Awkward Formula}}

In the spreadsheet formula language, some binary operators have an equivalent aggregate function which accepts any number of arguments: \f{+} correspons to \f{SUM}, \f{*} to \f{PRODUCT} and \f{\&} to \f{CONCATENATE}.

Thus a formula like \f{=A1+A2+A3+A4} can be rewritten to \f{=SUM(A1,A2,A3,A4)}, which is what the \rf{Replace Awkward Formula} refactoring, defined by Badame and Dig \cite{badame2012refactoring}, does.
The refactoring is especially useful when combined with the \rf{group references} refactoring, which rewrites it to \f{=SUM(A1:A4)}.


\subsection{User Interface}

In the user interface, this refactoring is combined with the \rf{Introduce Conditional Aggregate} as a \emph{Introduce (Conditional) Aggregate} function.
This refactoring is a one-click refactoring that is activated from the cell context menu, no additional user input is needed.
In the user interface it will always transparently be followed by the \rf{Group References} refactoring.

\subsection{Implementation}

\subsection{Detecting applicability}

This refactoring will only be offered to the user on a formula cell consisting of one of the applicable operators (\f{+},\f{*} or \f{\&})

\section{\rf{Introduce Conditional Aggregate}}

The formula language also contains the built-in conditional aggregate functions \f{SUMIF}, \f{AVERAGEIF} and \f{COUNTIF}.
These functions take two mandatory arguments: a range and a condition.
The function then performs its operation on every item that meets the condition.
In \f{SUMIF} and \f{AVERAGIF} this is often combined with the optional third argument, another range.
If this argument is supplied the first range is tested 

\subsection{User Interface}

\section{\rf{Fixate References}}

\todo{Unsure of ik deze nog wil implementeren, maar lijkt zeer laaghangend fruit.}

The Fixate References is similar to the \rf{Make Cell Constant} refactoring described by Badame \cite{badame2012refactoring}.
Maar beter want: user kan zelf selecteren welke cellen wel/niet absolute.

"Fixate references" beschrijft 100x beter wat de refactoring doet dan "Make cell constant". "Make cell constant" zou eerder impliceren dat je het resultaat van de cell berekening neemt en dat opslaat i.p.v. de formula. Wat trouwens ook weer een potentiele refactoring is, maar misschien een beetje een anti-pattern in excel.

\section{\rf{Introduce name}}

\todo{Kandidaat voor implementatie, meer laaghanged fruit.}

Cell (of range?) een naam geven, overal waar die naar gereferenced wordt vervangen door cell naam.
Of gelijk bij extract formula intregrereren!