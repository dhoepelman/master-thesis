
\documentclass[12pt,a4paper,onecolumn,oneside,parskip]{memoir}
%twoside for print version
\input{0-preamble/packages.tex}
\input{0-preamble/hoepelman-pagestyle.tex}
\input{0-preamble/commands.tex}
\input{0-preamble/font.tex}

\maxsecnumdepth{subsection} % chapters, sections, and subsections are numbered
\maxtocdepth{subsection} % chapters, sections, and subsections are in the Table of Contents

\newcommand{\todo}[1]{\textbf{TODO: #1}}
\newcommand{\ignore}[1]{}
\newcommand{\f}[1]{\texttt{#1}}
\newcommand{\key}[1]{\textbf{#1}}
\newcommand{\rf}[1]{\textsc{\lowercase{#1}}}
\newcommand{\noparskip}[1]{{\parskip=0pt
#1
}}
\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

\nonzeroparskip

\begin{document}

\include{0-title/title}

\cleardoublepage

%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
\tableofcontents*

\clearpage
%\twocolumn

%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%
%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%---%%%

\chapter{Introduction}

Like all people, I sometimes get asked what I do for a living.
When I tell someone I am writing my master thesis in Computer Science, their eyes start to glaze over as they anticipate some explanation peppered with terms they will not understand about 
I then tell them my thesis is about spreadsheets and ask if they have ever worked with Excel, and nearly everyone who has ever worked in business or research has.
Nearly everyone has a horror story about that one unmaintainable spreadsheet that they had to work on, or that day their reporting system broke down because 2009 turned into 2010 and the spreadsheet only looked at the last digit.

This anecdotal evidence is mirrored in research.
Panko \cite{panko2006facing} estimates that 80\% to 95\% of businesses use spreadsheets in one of their processes.
Furthermore, almost all spreadsheets contain at least one error and 1 to 5\% of spreadsheet cells contains an error according to Panko \cite{panko1998we}.
Spreadsheets perform roles very similar to software in that they perform business-critical roles, are inherited throughout the organization and maintained by different users and accrue technical dept during and after the initial development period \cite{panko1998we}.
In short, spreadsheets can be classified as programs, and spreadsheet creators as end-user programmers.

This view, "spreadsheets are code", could be the one-sentence summary of the ideology of the Spreadsheet Lab, which is a part of the TU Delft Software Engineering Research Group (SERG).
Using this view as a baseline, the group has tried to translate tried and proven software engineering methods to the spreadsheet domain so that they could be used to improve spreadsheets, spreadsheet development practices and help spreadsheet programmers.
As part of this effort, a spreadsheet formula refactoring tool called BumbleBee was developed by Hermans and Dig \cite{hermans2014bumblebee}.
This tool allows a formula to be transformed into another by defining a transformation rule, which works very similar to a pattern or regular expression replacement in a text editor.

However this approach has the downside that it can only considers one formula, and not the spreadsheet as a whole.
This leads to a lack of power to implement all spreadsheet refactorings, such as those implemented by Badame and Dig \cite{badame2012refactoring} in earlier work.
I joined the group to extend the capabilities of BumbleBee so that it could take context into account when performing refactorings, and implement more refactorings in BumbleBee.

\begin{figure}
\centerfloat
\input{intro/refactoring-process}
\caption{Overview of refactoring process}
\label{fig:refactoring-process}
\end{figure}

After the initial literature research I started implementing refactorings, but encountered a fundamental problem in doing so.
The standard way of implementing refactorings, illustrated in Figure \ref{fig:refactoring-process}, is by parsing the source code to an Abstract Syntax Tree (AST), which represents the structure of the program.
This AST can then be manipulated into the desired form, after which it can be converted back to source code (this is called printing or pretty-printing).
While BumbleBee contained a home-grown parser, I found a range of formulas that were either not parsable, or parsed into an incorrect AST.
This made me refocus the purpose of my thesis into making a better parser for Excel formulas, as this would not only be very useful for implementing refactorings but would be beneficial to all future spreadsheet research projects.

\section{About this thesis}

\subsection{Contribution}

The contributions of this thesis are twofold. Firstly there is the stand-alone parser for Excel formulas called XLParser, which is open-source and available online\footnote{\url{https://github.com/spreadsheetlab/XLParser}}. The parser was tested on over a million formulas and failed to parse merely two formulas.
Details of this parser are published by Aivaloglou, Hoepelman and Hermans \cite{xlparser}.
This paper is partially re-used in this thesis report, and the parts re-used are my contribution to the paper.

The second contribution is an improved version of BumbleBee, which implements the refactorings described in Chapter \ref{chapter:implementingrefactorings}: \rf{Extract Formula}, \rf{Inline Formula}, \rf{Group References} and \rf{Introduce Conditional Aggregate}.
BumbleBee is also available online\footnote{TODO: URL Bumblebee.}.

\subsection{Attribution}

This thesis was performed at the TU Delft Spreadsheet Lab, and is partially based on a collaborative effort in that group.
During this thesis the Excel Formula parser XLParser was developed, and a paper describing it was accepted into the 15th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM 2015): \emph{A Grammar for Spreadsheet Formulas Evaluated on Two Large Datasets} by Efthimia Aivaloglou, David Hoepelman and Felienne Hermans \cite{xlparser}.
This paper is attached verbatim as published in appendix \ref{appendix:xlparser}.
Chapter \ref{chapter:anatomy} is based on section \rom{2} of the paper, and was primarily written by the thesis author.
Chapter \ref{chapter:parsing}  is an updated and extended version of section \rom{3} of the paper, and was primarily written by the thesis author with contributions from Efthimia Aivaloglou, except for section \ref{sec:parserevaluation}, which is a summary of section \rom{4} of the paper which was primarily written by Efthimia Aivaloglou, who also performed the evaluation.

The grammar implementation (XLParser) was primarily done by the thesis author, but the implementation is based on the previous (un-named) parser which was primarily developed by Efthimia Aivalgoglou and Felliene Hermans.
The tool used to evaluate XLParser, which extracts formulas from spreadsheet files, was developed as part of Infotron B.V.\footnote{\url{http://www.infotron.nl/}}, with many authors. The thesis author did not contribute to this tool.

The refactorings described in Chapter \ref{chapter:implementingrefactorings} were added to the existing BumbleBee Excel add-in developed by Felienne Hermans, but these refactorings were solely implemented by the author with very little of the existing infrastructure used.

\subsection{Outline}

A passing knowledge of Excel and more in-depth knowledge of Excel formulas is needed to read the rest of this thesis, which is bundled in chapter \ref{chapter:anatomy} "\nameref{chapter:anatomy}".
Chapter \ref{chapter:previouswork} details previous and related work on spreadsheet refactoring.
In chapter \ref{chapter:candidaterefactorings} potential spreadsheet refactorings which were not yet implemented in BumbleBee are identified.

The Chapters thereafter describe the implementation of the spreadsheet refactorings.
Chapter \ref{chapter:parsing} covers how XLParser parses spreadsheet formulas and why it was designed as it was.
Chapter \ref{chapter:implementingrefactorings} describes how spreadsheet refactorings are performed and the implementation details of the new refactorings.

\todo{Meer zodra thesis wat meer vlees heeft}

\clearpage
\section{Timeline and decisions taken}

\begin{tabularx}{\textwidth}{lX}
\toprule
December 2014 & Literature study on refactoring, refactoring spreadsheets, converting spreadsheets to programs. \\
& Thesis topic selection. \\
January 2015 & Studied practicality of generic spreadsheet refactoring language based on Bumblebee transformation language, deemed inviable. \\
& Gathered existing refactorings from spreadsheet literature and translated Fowler refactorings. \\
& Decided which refactorings to initially implement \\
& Familiarization with existing BumbleBee code \\
February 2015 & Implementing \rf{Inline Formula} \\
& Extended Bumblebee and parser to account for sheet and file names \\
March 2015 & Implementing \rf{Extract formula} \\
& Writing of paper "End user programming" \todo{} \\
April 2015 & Writing of paper "End user programming" \todo{} \\
& Various improvements to parser \\
May 2015 & Decision to rewrite parser to solve several fundamental problems \\
& Start work on XLParser \\
& Implementing \rf{Introduce (Conditional) Aggregate} \\
& Implementing \rf{Group references} \\
June 2015 & Continued work on XLParser: Initial release \\
& Writing of XLParser paper \\
July 2015 & Changing of refactoring UI to context-aware right-click menu, similar to IDE's \\
August 2015 & Continued work on XLParser: Several fixes to XLParser parse trees \\
& Camera-ready adjustment of XLParser paper \\
& Constructed demo application\footnote{\url{http://xlparser.perfectxl.nl/demo/}} for XLParser which shows the parse trees. \\
September 2015 & Continued work on XLParser: Adding structured references, file paths \\
& Porting BumbleBee and refactorings to XLParser-based implementations \\
\bottomrule
\end{tabularx}

\chapter{Previous and related work}
\label{chapter:previouswork}

\section{Refactoring}

\section{The BumbleBee spreadsheet refactoring suite}

\section{Other spreadsheet refactoring efforts}

%\chapter{Spreadsheet anatomy}
\include{anatomy/chapter}


%\chapter{Candidate spreadsheet refactorings}
%\label{chapter:candidaterefactorings}
%
%\section{Comparing spreadsheets to other programming paradigms}
%
%\subsection{Reactive programming}
%As explained in chapter \ref{chapter:anatomy}, the spreadsheet programming model is a variation of the dataflow programming model.
%Thus the most natural first comparison for spreadsheet is the \emph{reactive programming} paradigm, which is another variation of the dataflow programming model.
%Viewed from the RP model, all spreadsheet cells are observable values and every formula is an observer.
%One can attach a formula observer to a cell observable by making a reference, e.g. a formula \f{=A1+1} in cell B1 listens to the value of A1 and produces the value for B1.
%However currently no literature on refactoring reactive programs is known to the author, so no additional refactoring were found by comparing spreadsheets to reactive programs.
%
%\subsection{Functional programming}
%Spreadsheets program do not contain state (mutable variables) or side-effects
%\footnote{As long as one remains within the spreadsheet model. User-defined functions and inter-operation with external programs can cause side-effects.}
%and this immutability aspect is often associated with functional programming languages.
%However spreadsheets lack several other important concepts of functional languages such as first-class and higher-order functions, recursion\footnote{Most spreadsheet implementations allow for a form of recursion in the form of cycles in the dependency graph called circular references. However this is not the normal modus-operandi, triggers a warning and is generally only used to perform iterative calculations which are not otherwise possible in spreadsheets.}, lazy evaluation and type interference.
%
%\subsection{Translation of concepts}
%
%Some literature exist on refactoring functional programs, most prominent is the tool \textbf{Ha}skell \textbf{Re}factoring tool (HaRe) \cite{thompson2005refactoring}.
%Most of the described refactorings are either specific to Haskell, or only applicable because of concepts not available in spreadsheets.
%
%This makes all of the current literature on refactoring functional programs not applicable.
%\todo{Cite functional refactoring literature}
%
%\subsection{Object-oriented programming}
%
%By far 
%
%
%
%\section{Translating refactorings to the spreadsheet domain}
%
%Tabel met mogelijke refactorings.
%Subsecties voor alle geïmplementeerde refactorings.

%\chapter{Parsing spreadsheet formulas}
\include{parsing/chapter}

\chapter{Refactoring spreadsheets}
\label{chapter:implementingrefactorings}

\noindent
\begin{figure}[h!]
\hspace*{0.003\textwidth}
\input{implementation/refactoring-process-impl}
\caption{This chapter details the AST to AST transformations that implement the refactorings.}
\end{figure}

Refactoring a spreadsheet involves changing the sheets, cells and formulas in a workbook in such a way that the desired change is performed.
Excel provides an API to change the worksheet and cells, and most other elements of a workbook.
When it is desired to refactor formulas this means the original formula string must be changed into a new formula string.
This is usually implemented by parsing the formula, performing the desired transformations on the AST and then printing the AST back to a string form \cite{fowler1999refactoring}.
The inner workings of the parser are described in \ref{chapter:parsing}.
This chapter covers how the AST is transformed for each refactoring and how it is printed.

The refactorings were implemented in the BumbleBee Excel Add-In, and presented to the user through a context menu as seen in Figure X.
This context-menu automatically determines if a refactoring can be performed on the specific selected cell(s) and disables inapplicable refactorings.
\todo{Screenshot van het bumblebee refactoring context-menu}

It must be noted that all refactorings have a major deficiency: they cannot be undone.
The reason for this is a technical limitation imposed by Excel: the Excel undo-redo stack is not available to Excel Add-Ins.
Instead as soon as a Excel Add-In changes the Excel spreadsheet file, in fact as soon as it interacts with the internal document model even if it does not change anything, the Excel undo-redo stack gets cleared.
There is a fairly complicated way to work around this\footnote{Visual Basic for Application macros do have access to the undo-redo stack. Thus theoretically one could insert a VBA macro which saves the cells to be altered to the stack. However this has the major disadvantage of changing every spreadsheet file touched to a macro-enabled spreadsheet file and leaving a macro behind.}, this was deemed outside of the scope of this thesis.
As long as Excel keeps this limitation this will always be a severe limitation to any tool that automatically changes spreadsheet files for the user.

\section{\rf{Extract formula}}

The \rf{extract formula} refactoring is analogous to the \rf{extract method} (object oriented programming) or \rf{extract function} (functional programming) refactorings, and also to the \rf{extract local variable} refactoring.
All have in common that one takes a collections of composable units, removes these from the parent unit and places them into a new parent unit of the same type:

\begin{tabular}{@{}lll@{}}
	\toprule
	Refactoring & Composable unit & Parent unit \\
	\midrule
	Extract Method & Statements & Method \\
	Extract Function (Functional) & Expression & Function \\
	Extract Function (Imperative) & Statements & Function \\
	Extract local variable & Expression & Variable \\
	\textbf{Extract formula} & Expression & Formula \\
	\bottomrule
\end{tabular}

The goal of the \rf{extract formula} refactoring is to move part of a formula expression, a sub-formula, to another cell, which has the following potential advantages:

\begin{enumerate}
\item Remove "magic numbers" or other constants and make them easy to adjust.
\item Make a formula easier to understand by splitting it into more smaller components.
\item Reduce duplication in a formula by extracting common sub-formulas into another cell.
\end{enumerate}

\subsection{User interface}

\begin{figure}
\begin{minipage}[c][8cm][c]{0.5\textwidth}
\centering
\vspace*{\fill}
\includegraphics[height=3cm]{implementation/extractformula/21}
\subcaption{User selects cells to be refactored}
\label{fig:extractformulaexample2a}

\includegraphics[height=3cm]{implementation/extractformula/23}
\addtocounter{subfigure}{1}
\subcaption{Refactoring has been performed}
\label{fig:extractformulaexample2c}
\end{minipage}
\begin{minipage}[c][8cm][t]{0.5\textwidth}
\vspace*{\fill}
\centering
\includegraphics[height=7cm]{implementation/extractformula/22}
\addtocounter{subfigure}{-2}
\subcaption{User selects subformula to be extracted}
\label{fig:extractformulaexample2b}
\end{minipage}
\caption{An example application of \rf{Extract Formula}}
\label{fig:extractformulaexample2}
\end{figure}

The refactoring requires the user to select cell(s) to be refactored, type in the subformula to be extracted and select where the extraction should occur to.
Figure \ref{fig:extractformulaexample2} shows the process as experienced by the user.
The user first selects the formulas to be extracted (Figure \ref{fig:extractformulaexample2a}) and clicks the Extract Formula entry in the refactoring context menu (not shown).
A side-panel pops out which allows the user to enter the sub-formula to be extracted and where it should be extracted to (Figure \ref{fig:extractformulaexample2b}) and presses the Extract Formula button.
In the example the \f{50\%} subformula was extracted to the left, and Figure \ref{fig:extractformulaexample2c} shows the situation after the user has named the new column.

\subsection{Implementation}

The implementation consists of 2 parts.
The first part handles actual placement of the formula in the cells and the moving if neccesary, the second part operates solely on the formula and refactors it to the desired form.

\subsubsection{Formula Refactoring}

Call the original formula $F_{or}$, the refactored formula $F_{new}$, the (user-supplied) subformula to be extracted $F_{search}$.
The spreadsheet refactoring code also provides the target $F_{search}$ will be moved to as $F_{repl}$.
The refactoring works by first parsing all formulas to AST.
Then $AST_{or}$ is walked through and every occurrence of $AST_{search}$ is replaced by $AST_{repl}$, yielding $AST_{new}$, this is illustrated in Figure \ref{fig:extractformulaASTtransformations}.
$AST_{new}$ is then printed to $F_{new}$, which is returned.
The C\# code for the AST replacement can be found in Listing \ref{lst:astreplace}.

You might have noticed that the AST transformation is somewhat similar to the BumbleBee formula transformation rules.
However, it is complimentary rather than identical.
We could have tried to written this transformation as a BumbleBee rule "\f{=I2 + [a] * I2}".
However, BumbleBee would have searched for the "outer" formula, keeping the \f{[a]} $\gets$ \f{50\%} available for the replacement rule.
In contrast, this transformation searches for the \f{[a]} "inner" formula, and replaces it with something different.

\begin{figure}
\centering
\input{implementation/extractformula/extractformulaast.tex}
\caption{AST transformation to implement extract formula refactoring}
\label{fig:extractformulaASTtransformations}
\end{figure}

\subsubsection{Spreadsheet refactoring}

\todo{Dit moet nog iets duidelijker.}

The spreadsheet refactoring differs slightly depending on if the subformula get to a single cell or if the extraction occurs in a direction.
If to a single cell, that cell gets assigned the subformula.
Otherwise new cells are created in the appropriate direction and they get assigned the subformula.

The AST replacement is then performed on the original formula, and the new formula is assigned to the cell that needs to be refactored.
If multiple cells are refactored at once, the above process is performed for all of them.
Formulas with the same R1C1 $F_{or}$ have the same R1C1 $F_{new}$ so the output of the formula refactoring is cached.

The C\# code for the spreadsheet refactoring can be found in Listing \ref{lst:extractformula}.

\subsection{Detection of applicability}

Extract formula is always applicable to a formula cell, as even a very simple formula like \f{=1} still has a component that can be extracted.
In this case if \f{=1} would be extracted to \f{A1} the original cell would become \f{=A1}.
Of course, whether it is a good thing to perform this refactoring is dubious, but BumbleBee relies on the user to make this assessment.

\subsection{Improvements over RefBook \rf{Extract row or column} and \rf{Extract Literal}}
\label{subsubsec:improvementsextractformula}

Two specialized versions of this refactorings where previously described by Bamade and Dig \cite{badame2012refactoring} and implemented in their RefBook tool.
Refbooks \rf{Extract Row or column} and \rf{Extract Literal} refactorings can both be performed by \rf{Extract formula}.

The author has chosen to not keep the \rf{extract row or column} refactoring name because it does not fully describe the refactoring, a full row or column does not necessarily have to be extracted, and to keep the name in line with refactoring names in other domains.

The RefBook \rf{extract literal} refactoring can put a constant value into a cell and replace the occurrences of it with references to that cell, this can also be achieved with the BumbleBee \rf{extract formula} refactoring.
In addition this is possible for any constant expression, an expression without references, instead of only for constants.

The BumbleBee \rf{Extract Formula} refactoring has several advantages over Badame's implementation of \rf{Extract row or column}.
Firstly RefBook does not handle operator precedence.
This can be very problematic for this refactoring and in the authors opinion should prevent is from being implemented, because one of the prime properties of a refactoring should be that it does not change the program results.
Note that the RefBook authors were aware of this deficiency, and left this as future work.
This future work has been performed by the thesis author.

Secondly RefBook can only handle a single row or column, which has to have exactly the same R1C1 formula. It can only extract the subformula to a column right of or row up of the original range.
BumbleBee can handle arbitrarily shaped ranges, with the only requirement that the subformula to be extracted occurs in all selected formulas.
Furthermore in addition to extracting to a cell neighboring the original formula cell (up, down, left or right) it can also extract the subformula to a single shared cell location.
This is very useful to remove duplication and makes the refactoring more universal by merging the \rf{extract literal} refactoring into it.

\section{\rf{Inline formula}}

\section{\rf{Introduce (Conditional) Aggregate}}

\section{\rf{Group References}}

\section{\rf{Fixate References}}

\todo{Unsure of ik deze nog wil implementeren, maar lijkt zeer laaghangend fruit.}

The Fixate References is similar to the \rf{Make Cell Constant} refactoring described by Badame \cite{badame2012refactoring}.
Maar beter want: user kan zelf selecteren welke cellen wel/niet absolute.

"Fixate references" beschrijft 100x beter wat de refactoring doet dan "Make cell constant". "Make cell constant" zou eerder impliceren dat je het resultaat van de cell berekening neemt en dat opslaat i.p.v. de formula. Wat trouwens ook weer een potentiele refactoring is, maar misschien een beetje een anti-pattern in excel.

\section{\rf{Introduce name}}

\todo{Kandidaat voor implementatie, meer laaghanged fruit.}

Cell (of range?) een naam geven, overal waar die naar gereferenced wordt vervangen door cell naam.
Of gelijk bij extract formula intregrereren!

\chapter{Evaluation}


\chapter{Conclusion}

\section{Future Work}

\bibliographystyle{unsrt}
\bibliography{thesis}

\appendix

\chapter{Code listings}

\lstset{style=sharpc}
\begin{lstlisting}[float,caption={Formula AST replacement (simplified)}, label={lst:astreplace}]

/* Context contains the workbook and worksheet of a node */

public static ParseTreeNode Replace(ParseTreeNode subject, ParseTreeNode search, ParseTreeNode replace, Context csub, Context csearch, Context crepl) {
	// Check if the subject matches search
	if(Equals(subject, search, csub, csearch)) {
		// We can return the replacement.
		// Moveto handles changing reference prefixes if necesarry 
		return MoveTo(replace, crepl, csub);
	}
	
	// No match, if we are at a leaf node, simply return the leaf node
	if (subject.ChildNodes.Count == 0) return subject;
	
	// Otherwise continue the replacement on the child nodes
	return new ParseTreeNode() {
		Type = subject.Type(),
		// Select is C#'s map
		ChildNodes = subject.ChildNodes.Select(child => Replace(child, search, replace, csub, csearch, crepl))
	};
}

public static bool Equals(ParseTreeNode p1, ParseTreeNode p2, Context c1, Context c2) {
	
	// RemoveNonEqualityAffectingNodes removes things like brackets,
	// which do not affect the equality of nodes
	p1 = RemoveNonEqualityAffectingNodes(p1);
	p2 = RemoveNonEqualityAffectingNodes(p2);
	
	// Qualify adds workbook and worksheet prefix to all references, so that
	// equality isn't affected by whether or not these are supplied in the original formula
	p1 = c1.Qualify(p1);
	p2 = c2.Qualify(p2);
	
	return p1.Type() == p2.Type()
		// Compare the token values if these are tokens
	    && (p1 is Terminal && p1.Token.ValueString == p2.Token.ValueString)
	    // Compare child count
	    && p1.ChildNodes.Count == p2.ChildNodes.Count
	    // Check if all children are equal
	    && p1.ChildNodes.Zip(p2.ChildNodes).All((ch1, ch2) => Equals(ch1, ch2, c1, c2));
}
\end{lstlisting}

\lstset{style=sharpc}
\begin{lstlisting}[float,caption={Extract formula refactoring (simplified)}, label={lst:extractformula}]
public void ExtractFormula(Range applyto, Location moveto, ParseTreeNode subformula) {
	
	/** Check if all applyto cells contain subformula **/
	
	/** Check if target cell is empty **/
	
	/** Check if subformula contains any non-absolute references **/
	
	// Set the target cell to the subformula
	moveto.Formula = subformula.Print();
	// and get its parsed address reference
	var replacementAST = moveto.Address().Parse();
	
	// Apply the refactoring once per unique R1C1 formula
	foreach (var uniqueR1C1 in applyto.Cells.GroupBy()(c => c.FormulaR1C1)) {
		var prototype = uniqueR1C1.First();
		var AST_or = prototype.Parse();
		
		prototype.Formula = Replace(AST_or, subformula, replacementAST, /*...*/).Print();
		
		foreach(var cell in uniqueR1C1) {
			cell.FormulaR1C1 = prototype.FormulaR1C1;
		}
	}
}

public void ExtractFormula(Range applyto, Direction dir, ParseTreeNode subformula) {
	
	/** Check if all applyto cells contain subformula **/
	
	/** Insert new cells in the appropriate direction **/
	
	/** Set all new cells to contain the subformula formula **/
	
	// Apply the refactoring once per unique R1C1 formula
	foreach (var uniqueR1C1 in applyto.Cells.GroupBy()(c => c.FormulaR1C1)) {
		var prototype = uniqueR1C1.First();
		var AST_or = prototype.Parse();
		var replacementAST = prototype.Offset[dir].Address().Parse();
		
		prototype.Formula = Replace(AST_or, subformula, replacementAST, /*...*/).Print();

		foreach(var cell in uniqueR1C1) {
			cell.FormulaR1C1 = prototype.FormulaR1C1;
		}
	}
}
\end{lstlisting}

\lstset{style=sharpc}
\begin{lstlisting}[float,caption={XLParser Print method (simplified)}, label={lst:xlparserprint}]
public static string Print(this ParseTreeNode node) {
  // Print token values
  if(node is Terminal) return node.Token.Text;
  
  // Select is C#'s map function
  var ch = node.ChildNodes.Select(Print).ToList();
  
  switch(node.Type()) {
     case "ArrayFormula":
       return "{=" + ch[0] + "}";
     case "FunctionCall":
       if(node.IsBinaryOperation()) {
          return ch[0] + " " + ch[1] + " " + ch[2];
       }
       if(node.isNamedFunction()) {
          return String.Join("", ch) + ")";
       }
       // some more conditions
       break;
     // More cases for every node type
  }
}
\end{lstlisting}

\chapter{A Grammar for Spreadsheet Formulas Evaluated on Two Large Datasets}
\label{appendix:xlparser}

The following is a verbatim copy of the papers as it was published in the proceedings of SCAM 2015.

\clearpage

\includepdf[pages={1-10}]{appendix/scam-xlparser.pdf}

\clearpage

\vspace*{\fill}

\centering
\large{End of appendix \ref{appendix:xlparser}}

\vspace*{\fill}

\end{document}

